<html>
    <head>
        <link rel="Stylesheet" type="text/css" href="../myStyle.css" />
		<link rel="stylesheet" type="text/css" href="../shCore.css"/>
		<link rel="stylesheet" type="text/css" href="../shCoreDefault.css"/>
		<script type="text/javascript" src="../shCore.js"></script>
		<script type="text/javascript" src="../shBrushPhp.js"></script>
		<script type="text/javascript" src="../shBrushJScript.js"></script>
		<script type="text/javascript" src="../shBrushXml.js"></script>
        <title>Codeforces Round #127(Div.2)</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<div id="nav">
	<ul>
		<li><a href="../index.html">ZAKIR's wiki</a></li>
		<li><a href="../index.html">首页</a></li>
		<li><a href="http://www.zkgo.info/blog" target="_blank">博客</a></li>
		<li><a href="http://github.com/qBug" target="_blank">Github</a></li>
	</ul>
</div>
<div id="wrapper">
	<div class="content">
		
<h1 id="toc_1" class="justcenter">Codeforces Round #127(Div.2)</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">Codeforces Round #127(Div.2)</a>
<ul>
<li><a href="#toc_1.1">A. LLPS</a>
<ul>
<li><a href="#toc_1.1.1">问题描述</a>
<li><a href="#toc_1.1.2">思路</a>
</ul>
<li><a href="#toc_1.2">B. Brand New Easy Problem</a>
<ul>
<li><a href="#toc_1.2.1">问题描述</a>
<li><a href="#toc_1.2.2">思路</a>
</ul>
<li><a href="#toc_1.3">C. Clear Symmetry</a>
<ul>
<li><a href="#toc_1.3.1">问题描述</a>
<li><a href="#toc_1.3.2">思路</a>
</ul>
<li><a href="#toc_1.4">D. Guess That Car!</a>
<ul>
<li><a href="#toc_1.4.1">问题描述</a>
<li><a href="#toc_1.4.2">思路</a>
</ul>
<li><a href="#toc_1.5">E. Fragile Bridges</a>
<ul>
<li><a href="#toc_1.5.1">问题描述</a>
<li><a href="#toc_1.5.2">思路</a>
</ul>
<li><a href="#toc_1.6">参考资料</a>
</ul>
</ul>
</div>
<h2 id="toc_1.1" class="justcenter">A. LLPS</h2>
<h3 id="toc_1.1.1">问题描述</h3>
<p>
寻找给定字符串字典序最大的回文子序列。如"poster"字典序就比"post"大。
</p>
<h3 id="toc_1.1.2">思路</h3>
<p>
给定的字符串比较短，长度不超过10，直接深度优先搜索即可。若当前形成的字符串是回文串，检查是否比答案字典序大即可。
</p>

<h2 id="toc_1.2" class="justcenter">B. Brand New Easy Problem</h2>
<h3 id="toc_1.2.1">问题描述</h3>
<p>
给出一个题目的描述，找出在之前的SRM（<del>这题是在吐槽Topcoder吗</del>）中是否出现过类似的题目，类似定义为：对新题目的单词进行全排列，若某一次的排列恰好为某题的子序列，则两题目相似，相似度\( p=n*(n-1)/2-x+1 \)，其中n为新题目单词数，x为逆序数（即与原排列次序相反的单词对数，如：原排列为123，则312的逆序数为2：(3,1),(3,2)），为新题目找出相似度最大的原题来，没有则输出“Brand new problem!”。
</p>
<h3 id="toc_1.2.2">思路</h3>
<p>
由于n&lt;=4，官方的题解真是简单粗暴，四个for循环即可。。。我还是用DFS得到新问题的全排列，对于一个原题，去掉新问题中没出现过的单词，若不重复单词数等于新问题的单词数，说明原题肯定包含新问题的子序列，再用DFS搜出原题处理后的序列包含的逆序数最小的一个全排列。
</p>

<h2 id="toc_1.3" class="justcenter">C. Clear Symmetry</h2>
<h3 id="toc_1.3.1">问题描述</h3>
<p>
对于一个元素只能取值为0或1的矩阵
</p>

<p>
定义clear矩阵为：所有与值为1的元素相邻的元素值为0.
</p>

<p>
定义矩阵的sharpness为：矩阵中1的个数。
</p>

<p>
给定矩阵的sharpness请找出上下左右对称的边长最短的矩阵。输出边长。
</p>
<h3 id="toc_1.3.2">思路</h3>
<p>
规律题，直觉上来说，一个边长（或者行数）为n的矩阵，最多可以包含(n<sup><small>2</small></sup>+1)/2个1，就像国际象棋的棋盘一样，在黑格摆1.根据所求矩阵的特征，所求的n肯定为奇数，若为偶数，最中间两行肯定全为0（若存在1，根据对称的要求，则上下对称位置也得是1，这与相邻元素不为1矛盾），列也是一样的。所以从1开始找(n<sup><small>2</small></sup>+1)/2&gt;=x的奇数即可。 <strong>注意</strong> x=1,2,3的时候并不满足该规律，请自行手算。
</p>

<h2 id="toc_1.4" class="justcenter">D. Guess That Car!</h2>
<h3 id="toc_1.4.1">问题描述</h3>
<p>
有n+1条水平线和m+1条垂直线画出n*m个停车位,每个停车位长宽均为4米，每个停车位上停一辆车，给出每个车的稀有度，若识别一辆车所花的时间为所处观察点到停车位正中间的距离平方乘以稀有度，即d<sup><small>2</small></sup>*c<sub><small>ij</small></sub>观察点只能设定在水平线和垂直线的交点处。求一个观察点坐标使得识别所有车所花时间最短。
</p>
<h3 id="toc_1.4.2">思路</h3>
<p>
由题意可知，所求时间为sum(c<sub><small>ij</small></sub>* ((x-x<sub><small>ij</small></sub>)<sup><small>2</small></sup>+(y-y<sub><small>ij</small></sub>)<sup><small>2</small></sup>))=sum(c<sub><small>ij</small></sub>* (x-x<sub><small>ij</small></sub>)<sup><small>2</small></sup>)+sum(c<sub><small>ij</small></sub>*(y-y<sub><small>ij</small></sub>)),找到合适的x,y即可，由式子可知，x,y可以分开计算。如果直接遍历所有交叉点计算时间和的话，时间复杂度为O(n*m*n+n*m*m)，由于n和m都小于等于10<sup><small>3</small></sup>,所以直接计算是会超时的。可以预处理每行的所有车稀有度的和以及所有列的车稀有度和，由于处于同一行的车辆x坐标都一样，所以可以将该行的稀有度和直接乘以x方向距离差平方，分别循环0到n，0到m，得到使和最小的x和y，时间复杂度为(n*m+n*n+m*m).
</p>

<h2 id="toc_1.5" class="justcenter">E. Fragile Bridges</h2>
<h3 id="toc_1.5.1">问题描述</h3>
<p>
n-1座桥将n个岛连成一条线，给出每座桥可以通过的次数，请设定起点和终点使通过桥的次数总和最大。
</p>
<h3 id="toc_1.5.2">思路</h3>
<p>
我们知道，如果要从岛i到岛j（i&lt;j,其实从i出发到j和从j出发到i通过桥的次数总和是一样的），通过桥的次数总和肯定为奇数次，0到i之间走的次数肯定为偶数（因为从i出发要回到i），同理，j到n之间走的次数也为偶数。定义left<sub><small>i</small></sub>为从i出发向左走再回到i通过桥的最大次数和，right<sub><small>j</small></sub>为从j出发向右走再回到j所通过桥的最大次数和，odd<sub><small>i</small></sub>为不大于桥i通过次数的最大的奇数，oddSum<sub><small>i</small></sub>为岛i左侧所有桥的odd的和。给定i,j(i&lt;j),题目所求的最大次数和就等于left<sub><small>i</small></sub>+right<sub><small>j</small></sub>+(oddSum<sub><small>j</small></sub>-oddSum<sub><small>i</small></sub>)=(left<sub><small>i</small></sub>-oddSum<sub><small>i</small></sub>)+(right<sub><small>j</small></sub>+oddSum<sub><small>j</small></sub>)。两个for循环暴力找i,j肯定超时，可以让j遍历0到n，维护一个maxL=(left<sub><small>i</small></sub>-oddSum<sub><small>i</small></sub>)的最大值，若maxL+right<sub><small>j</small></sub>+oddSum<sub><small>j</small></sub>&gt;ans更新最优值即可。
</p>

<h2 id="toc_1.6">参考资料</h2>
<p>
[1]<a href="http://codeforces.com/blog/entry/4808">Codeforces Tutorial</a>
</p>

	</div>
	<script type="text/javascript">
		SyntaxHighlighter.all();
		</script> 
		<div id="footer">
			<hr>
			<div><a href="index.html">首页</a> | <a href="http://www.zkgo.info/blog/?page_id=2">关于</a> | <a href="http://www.zkgo.info/blog/?page_id=2">与我联系</a> | <a href="http://zkgo.info/blog" target="_blank">博客</a></div>
			<div>Powered by Vimwiki. Hosted on Github. &copy; 2012 ZAKIR</div>
		</div>
</div>
</body>
</html>

